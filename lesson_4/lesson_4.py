"""
функция - блок кода, вызываемый многократно

def - слово для вызова функции

по правилам - читать PEP-8
"""

def hello():
    print('Hello')

print(type(hello))
hello()
hello()

say_hello = hello
say_hello()


"""
аргументы функции
# значение по умолчанию (p=2 например) должно иметь неизменяемый тип данных
потому что значение хранится в памяти
# аргументы по умолчанию необходимо указывать только после передаваемых в функцию
# например для функции подключения к БД
"""

def hello_username(name):
    print('Hello,', name)

hello_username('Python')
hello_username('JS')
hello_username('Вася')



def summa(a, b):
    print(a + b)

summa(1, 3)


def poww(x, p=2):
    print(x ** p)


poww(5)


"""
Передача значений аргументов по ссылке - надо дополнительно почитать литературу - ничего не понял
"""

def parse(src, output):
    src = src.strip('.') # метод обрезания строк - strip) - в совркупности со сплитом на переменную никак не повлияло

    for i in src.split():   # метод split - для разбивания строк по словам
        output.append(i)  # append - признак списка

src = 'Python. Is .Programming. Lang.'
output = []

print(src, output)
parse(src, output)
print(src, output)

# получилась ерунда, потому что так устроен язык - нельзя поменять строковую переменную по ссылке


def f(i, l=None): # теперь можно вызвать функцию с пустым аргументом по умолчанию
    l = l or [] 
"""
    l = l if is not None else [] - это отстой

    l = l or []   # переданный аргумент приводится к True,
    т.о. если переданный аргумент False то будет значение по умолчанию

    всегда стараться использовать or а не and, проверки на ложь
"""


"""
Как вернуть значение из функции

после return код выполняться не будет
"""
def minus(a, b):
    return a - b
    a = a * b # никогда не выполнится

r = minus(1, 2)
print(r)


"""
блок else это зло, основное использование при проверке на "True"
хороший пример избавления от лестницы if else:

if not f1():
    'error' //return
if not f2()
    'error' //return
if not f3()
    'error' //return


если функция ничего не возвращает, то это процедура
если возвращает, то функция

"""

# в питоне функция может возвращать много значений
def f2():
    return 1, 2, 3 # тут вернется кортеж, как (1, 2, 3)

a, b, c = f2() # если бы были скобки в строке выше, то все значение попало бы в переменную a кортежем



"""
переменное количество аргументов в описании функции
частая ситуация, когда сначала вообще неизвестно количество аргументов

чтобы принять неизвестное количество аргументов - синтаксис:
*args

именованные аргументы:
к нему можно обращаться по имени, позиционные - синтаксис:
**kwargs

args и kwargs - устоявшиеся названия, могут быть изменены, главное это *
"""
def demo_func(i, *args, **kwargs): 
    print(i, args, type(args)) # args - кортеж tuple (должен быть в конце, после определенных аргументов)
    print(kwargs, type(args)) # kwargs - словарь dict

demo_func(1, 2, 3, j=4)
demo_func(10, 20, k=True, e=456)


def f3(i=1, j=1, *args):
    print(i, j, args)

f3(2, 2, 5, 5)
"""
f3(2, 5, 5, j=2) # будет ошибка надо: def f3(i=1, *args, j=1): или def f3(i=1, *args, j=1, **kwargs):
"""

"""
переменное количество аргументов при вызове функции

"""

def f4(i, j, k, a=None, b=None, c=None):
    print(i, j, k)
    print(a, b, c)

args = [1, 2, 3]
kwargs = {
    'a': 10,
    'b': 20,
    'c': 30,
}
f4(*args, **kwargs) # обычно используется вместе (будет в декораторах)


"""
анонимная функция
lambda
свой синтаксис и всегда пишется в одну строку
всегда возвращает результат, return не нужен

по PEP-8 осуждается присвоение функции для переменной (код ниже)

"""

sqrt = lambda x: x ** 0.5
# lambda: pass
# lambda x, y: pass
print(sqrt(9))

def f5(x, cb):
    return cb(x)

print(f5(25, sqrt)) # или правильно: print(f5(25, lambda x: x ** 0.5))


"""
Области видимости переменной

глобальная - все что вне функции
локальная - область видимости функции - все описываемые в функции аргументы, перечисленные в ней переменные

словари locals и globals - туда лучше не смотреть
"""

"""
Замыкания - когда внутри одной функции описываем другую функцию.


"""

# функция каррирования
def trim(chars=None):
    #Область видимости (локальная) функции trim
    #замкнутая область
    def f(s):
        #область видимости (локальная) функции f
        return s.strip(chars)
    return f

spaces_trim = trim()
slashes_trim = ('/\\')
print(spaces_trim('    Hello       '))

# print(slashes_trim('////url//\\\//'))
# пока существует spaces_trim - область trim() существует


"""
рекурсивная функция


пример - факториал
"""
def factorial(x):
    # прямая рекурсия
    return 1 if x == 0 else x * factorial (x - 1)


print(factorial(5))



# косвенная рекурсия
"""
def a():
    b()

def b():
    a()
"""


"""
никогда не использовать глобальные переменные
чтобы использовать в функции переменную родительской функции (например изменить значение)
и не создать при этом локальную переменную (одноименную), то в функции необходимо прописать конструкцию:
nonlocal <имя переменной>
"""
































































